<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementing a Parser - Writing a Compiler in Rust from scratch</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="error_handling.html"><strong aria-hidden="true">3.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="error_handling_with_ariadne.html"><strong aria-hidden="true">3.1.</strong> Error Handling with ariadne</a></li><li class="chapter-item expanded "><a href="error_handling_with_codespan_reporting.html"><strong aria-hidden="true">3.2.</strong> Error Handling with codespan-reporting</a></li></ol></li><li class="chapter-item expanded "><a href="lexical_analysis.html"><strong aria-hidden="true">4.</strong> Lexical Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="finite_automata.html"><strong aria-hidden="true">4.1.</strong> Finite Automata</a></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">4.2.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="lexer.html"><strong aria-hidden="true">4.3.</strong> Lexer</a></li></ol></li><li class="chapter-item expanded "><a href="parsing_and_syntax_analysis.html"><strong aria-hidden="true">5.</strong> Parsing and Syntax Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="abstract_syntax_trees.html"><strong aria-hidden="true">5.1.</strong> Abstract Syntax Trees</a></li><li class="chapter-item expanded "><a href="context_free_grammars.html"><strong aria-hidden="true">5.2.</strong> Context-free Grammars</a></li><li class="chapter-item expanded "><a href="parsing_techniques.html"><strong aria-hidden="true">5.3.</strong> Parsing Techniques</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recursive_descent_parsing.html"><strong aria-hidden="true">5.3.1.</strong> Recursive Descent Parsing</a></li><li class="chapter-item expanded "><a href="ll_k_parsing.html"><strong aria-hidden="true">5.3.2.</strong> LL(k) Parsing</a></li><li class="chapter-item expanded "><a href="lr_parsing.html"><strong aria-hidden="true">5.3.3.</strong> LR Parsing</a></li></ol></li><li class="chapter-item expanded "><a href="implementing_an_ast.html"><strong aria-hidden="true">5.4.</strong> Implementing an AST</a></li><li class="chapter-item expanded "><a href="implementing_a_parser.html" class="active"><strong aria-hidden="true">5.5.</strong> Implementing a Parser</a></li></ol></li><li class="chapter-item expanded "><a href="semantic_analysis.html"><strong aria-hidden="true">6.</strong> Semantic Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="symbol_tables.html"><strong aria-hidden="true">6.1.</strong> Symbol Tables</a></li><li class="chapter-item expanded "><a href="type_checking.html"><strong aria-hidden="true">6.2.</strong> Type Checking</a></li><li class="chapter-item expanded "><a href="implementing_a_symbol_table.html"><strong aria-hidden="true">6.3.</strong> Implementing a Symbol Table</a></li><li class="chapter-item expanded "><a href="implementing_a_semantic_analyzer.html"><strong aria-hidden="true">6.4.</strong> Implementing a Semantic Analyzer</a></li></ol></li><li class="chapter-item expanded "><a href="intermediate_representation.html"><strong aria-hidden="true">7.</strong> Intermediate Representation</a></li><li class="chapter-item expanded "><a href="code_generation.html"><strong aria-hidden="true">8.</strong> Code Generation</a></li><li class="chapter-item expanded "><a href="postlude.html"><strong aria-hidden="true">9.</strong> Postlude</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Writing a Compiler in Rust from scratch</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="implementing-a-parser"><a class="header" href="#implementing-a-parser">Implementing a Parser</a></h1>
<p>So far, we have a lexer and a way to represent tokens. Next, we need to implement the parser.</p>
<p>We'll be using <a href="./recursive_descent_parsing.html"><strong>Recursive Descent Parsing</strong> (RDP)</a> to implement the parser.</p>
<h2 id="the-parser-struct"><a class="header" href="#the-parser-struct">The <code>Parser</code> struct</a></h2>
<p>Let's define a struct for our parser. It'll own the stream of <code>Token</code>s, and it should keep track of the position in the stream.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Instead of owning the <code>Vec&lt;Token&gt;</code>, we could use a reference or better, an iterator. However, for simplicity, we'll use <code>Vec&lt;Token&gt;</code>.</p>
</blockquote>
<h3 id="safe-memory-management"><a class="header" href="#safe-memory-management">Safe memory management</a></h3>
<p>We need to be careful in designing here, since while the stream of tokens may be immutable, the position is <em>not</em>. Let's implement a basic <code>struct</code> and see why it may be a problem:</p>
<pre><code class="language-rust ignore">pub struct Parser {
    tokens: Vec&lt;Token&gt;,
    position: usize,
}

impl Parser {
    // ...

    // Expect a token of a certain type
    fn expect(&amp;mut self, kind: TokenKind) -&gt; Result&lt;&amp;Token&gt; {
        // Get the current token
        let current: &amp;Token = self.current()?;      // Immutable borrow

        // Move to the next token
        self.position += 1;                         // Mutable borrow

        if current.kind == kind {
            Ok(current)
        } else {
            Err("Unexpected token")
        }
    }
}</code></pre>
<p>*<em>Assume the other functions are implemented</em></p>
<p>Here, we have a problem. We're trying to borrow <code>self</code> mutably and immutably at the same time (as labelled in the code). This isn't allowed, since Rust's borrow checker ensures that:</p>
<ol>
<li>There are no mutable references when there are immutable references</li>
<li>There are no references when there are mutable references</li>
</ol>
<p>To solve this problem, we can use <code>RefCell</code> to allow for interior mutability. This will allow us to borrow <code>self</code> mutably and immutably at the same time. It works by checking the borrow rules at runtime, rather than compile time.</p>
<p>Let's redefine <code>Parser</code> using <code>RefCell</code>:</p>
<pre><code class="language-rust ignore">use std::cell::RefCell;

pub struct Parser {
    tokens: Vec&lt;Token&gt;,
    pos: RefCell&lt;usize&gt;,
}</code></pre>
<h3 id="helper-methods"><a class="header" href="#helper-methods">Helper methods</a></h3>
<p>Before we develop the methods for each non-terminal, we should introduce some helper functions to reduce the boilerplate code we write.</p>
<h4 id="position"><a class="header" href="#position">Position</a></h4>
<p>Whilst we may not use this method when parsing, the helper methods we'll introduce later on will need to get the position we're currently at. Since it's somewhat of a hassle to get the position from the <code>RefCell</code>, we'll define a helper method for it:</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Get position
    fn pos(&amp;self) -&gt; usize {
        *self.pos.borrow()
    }
}</code></pre>
<p>Easy peasy. Now, we can use <code>self.pos()</code> to get the current position.</p>
<p>We may also want to advance, and it's prettier to use functions so:</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Advance the parser by one token
    fn advance(&amp;self) {
        *self.pos.borrow_mut() += 1;
    }
}</code></pre>
<h4 id="token-access"><a class="header" href="#token-access">Token access</a></h4>
<p>Throughout parsing, we'll continually want to get the current token we're parsing. There is a possibility the <code>pos</code> may be <strong>out of bounds</strong>, so we'll opt for returning <code>Option&lt;&amp;Token)</code> -- which, coincidentally, is the return value for <code>Vec::get</code>.</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Get the current token
    fn current(&amp;self) -&gt; Option&lt;&amp;Token&gt; {
        self.tokens.get(self.pos())
    }
}</code></pre>
<p>This is a little messy since we'll need to handle the case where we reached the end of the stream. We can use some helpful features of <code>Option</code> to make this cleaner. This way, we will return <code>Result&lt;&amp;Token&gt;</code> instead, which we can use the <code>?</code> operator to handle.</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Get current token
    /// Raises an error if at EOF
    fn current_or_eof(&amp;self) -&gt; Result&lt;&amp;Token&gt; {
        self.current() // get the current token
            .filter(|token| token.kind != TokenKind::Eof) // remove it if it's EOF
            .ok_or_else(|| anyhow!(self.eof_error())) // raise an error if none
    }
}</code></pre>
<p>There is a lot going on here, so let's break it down:</p>
<ol>
<li><code>self.current()</code> gets the current token</li>
<li><code>filter</code> removes the token if it's EOF</li>
<li><code>ok_or_else</code> raises an error if there are no tokens left</li>
</ol>
<p>We can also create a helper method <code>eof_error()</code> to generate the error message:</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Get the last token and return an EOF error
    fn eof_error(&amp;self) -&gt; LangError {
        let token = self.tokens.last().unwrap();
        LangError::UnexpectedEOF(token.span.clone())
    }
}</code></pre>
<p>Nothing special, all simple.</p>
<h4 id="expecting-a-token"><a class="header" href="#expecting-a-token">Expecting a token</a></h4>
<p>We're often going to need to expect a certain token, simply meaning we need to guarantee that the token we're currently parsing is exactly a certain kind. The process is essentially:</p>
<ol>
<li>Get the current token and advance</li>
<li>Check if it's the expected token</li>
</ol>
<p>Nothing too major.</p>
<pre><code class="language-rust ignore">impl Parser {
    /// Expect a token and advance
    /// Does not work with EOF
    fn expect(&amp;mut self, kind: TokenKind) -&gt; Result&lt;&amp;Token&gt; {
        let current: &amp;Token = self.current_or_eof()?;
        self.advance();

        if current.kind == kind {
            Ok(current)
        } else {
            Err(anyhow!(LangError::ExpectedToken {
                expected: kind,
                found: current.kind.clone(),
                span: current.span.clone(),
            }))
        }
    }
}</code></pre>
<h2 id="non-terminal-methods"><a class="header" href="#non-terminal-methods">Non-terminal methods</a></h2>
<p>Let's start with the start symbol \(S\) of our grammar: <code>program</code>.</p>
<p>Recall the <a href="./context_free_grammars.html">grammar</a> we defined:</p>
<details>
<summary><strong>View the grammar</strong></summary>
<pre><code class="language-ebnf">program           ::= item*

item              ::= function_decl
                    # | struct_decl
                    # | enum_decl
                    # | impl_block

function_decl     ::= "fn" IDENTIFIER "(" {parameter_list} ")" "-&gt;" type block

parameter_list    ::= parameter ("," parameter)*

parameter         ::= IDENTIFIER ":" type

type              ::= primitive_type
                    # | user_defined_type
                    # | tuple_type
                    # | reference_type
                    # | array_type
                    # | function_type

primitive_type    ::= "int" | "float" | "bool"

block             ::= "{" statement* "}"

statement         ::= expression
                    | variable_decl
                    | flow_statement
                    | return_statement


expression        ::= primary_expression
                    | unary_expression
                    | binary_expression

primary_expression ::= literal
                    | IDENTIFIER
                    | "(" expression ")"
                    | function_call

literal           ::= INT | FLOAT | BOOLEAN

unary_expression  ::= "-" expression | "!" expression #| "&amp;" expression | "*" expression

binary_expression ::= expression OPERATOR expression

function_call     ::= IDENTIFIER "(" arguments ")"
arguments         ::= expression ("," expression)* | ε

variable_decl     ::= "let" IDENTIFIER ":" type "=" expression ";"

flow_statement    ::= "if" expression block {"else" block}

return_statement  ::= "return" {expression} ";"
</code></pre>
</details>
<p>The program section:</p>
<pre><code class="language-ebnf">program           ::= item*
</code></pre>
<h3 id="program"><a class="header" href="#program"><code>Program</code></a></h3>
<p>Simply means to parse 0 or more items. We can implement this as a loop that keeps parsing items until we reach the end of the file.</p>
<pre><code class="language-rust ignore">    /// Parse a program
    fn program(&amp;mut self) -&gt; Result&lt;Program&gt; {
        let mut items = Vec::new();
        while self.current().is_some() {
            items.push(self.item()?);
        }

        Ok(Program { items })
    }</code></pre>
<h3 id="item"><a class="header" href="#item"><code>Item</code></a></h3>
<p>The <code>item</code> non-terminal is where we introduce how to implement the pipe <code>|</code> in a parser. Right now, we are only parsing functions, so we'll only implement the function declaration. Regardless, we will implement it for scalability so we can add extra items later.</p>
<pre><code class="language-rust ignore">    /// Parse a single item
    fn item(&amp;mut self) -&gt; Result&lt;Item&gt; {
        let current = self.current_or_eof()?;

        let item = match current.kind {
            TokenKind::Fn =&gt; Item::FunctionDecl(self.function()?),
            _ =&gt; {
                return Err(anyhow!(LangError::ExpectedAnyToken {
                    expected: vec![TokenKind::Fn,],
                    found: current.kind.clone(),
                    span: current.span.clone(),
                }))
            }
        };

        Ok(item)
    }</code></pre>
<h3 id="function-and-parameter"><a class="header" href="#function-and-parameter"><code>Function</code> and <code>Parameter</code></a></h3>
<p>The <code>function</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">function_decl     ::= "fn" IDENTIFIER "(" {parameter_list} ")" "-&gt;" type block
</code></pre>
<p>There's a few new things here, main one being accumulating information throughout the process. The process is still straightforward, we follow the grammar:</p>
<ol>
<li>Expect <code>fn</code></li>
<li>Expect an <code>ident</code>, and store it</li>
<li>Expect <code>(</code>, and collect parameters
<ol>
<li>Get and store <code>ident</code></li>
<li>Expect <code>:</code></li>
<li>Get and store <code>type</code></li>
<li>Repeat until <code>)</code></li>
</ol>
</li>
<li>Expect <code>)</code></li>
<li>Expect <code>-&gt;</code></li>
<li>Get and store <code>type</code></li>
<li>Parse and store <code>block</code></li>
</ol>
<p>Let's implement it step by step. Let's start with the function signature, not including the body (<code>block</code>).</p>
<pre><code class="language-rust ignore">    fn function(&amp;mut self) -&gt; Result&lt;FunctionDecl&gt; {
        // "fn"
        self.expect(TokenKind::Fn)?;

        // IDENTIFIER
        let ident = self.ident()?;

        // "("
        self.expect(TokenKind::LParen)?;

        // parameter list
        let mut params: Vec&lt;Parameter&gt; = Vec::new();
        while self.current_or_eof()?.kind != TokenKind::RParen {
            let param = self.parameter()?;
            params.push(param);

            if self.current_or_eof()?.kind == TokenKind::Comma {
                self.advance();
            }
        }

        // ")"
        self.expect(TokenKind::RParen)?;

        // "-&gt;"
        self.expect(TokenKind::Arrow)?;

        // type
        let ty = self.type_()?;

        unimplemented!()
    }</code></pre>
<p>Here, we defined a few new functions:</p>
<ul>
<li><code>ident</code>
<ul>
<li>Although tokenization makes this simple, we like to reduce the boilerplate code we write</li>
</ul>
</li>
<li><code>parameter</code></li>
<li><code>type_</code>
<ul>
<li>Same as above</li>
</ul>
</li>
</ul>
<p>Finally, we should parse the block, and return the function. No, we will not implement the block parsing inside the <code>function</code> method. <code>block</code> is a non-terminal which exists in the grammar, so it will have its own method.</p>
<p>The reason we didn't create a method for <code>parameter_list</code> despite it being a non-terminal is for simplicity: the only dependant is <code>function</code>, so we can just implement it inside <code>function</code>. It's still perfectly fine (and probably better) to implement it as a separate method.</p>
<p>Let's add the block parsing and return the function:</p>
<pre><code class="language-rust ignore">    fn function(&amp;mut self) -&gt; Result&lt;FunctionDecl&gt; {
        // ...

        // block
        let block = self.block()?;

        Ok(FunctionDecl {
            ident,
            parameters: params,
            ty,
            block,
        })
    }</code></pre>
<p>The function signature isn't fully complete yet, we need to implement parsing the parameters too. Let's do that now.</p>
<pre><code class="language-rust ignore">    fn parameter(&amp;mut self) -&gt; Result&lt;Parameter&gt; {
        // Expect and store ident
        let ident = self.ident()?;

        // ":"
        self.expect(TokenKind::Colon)?;

        // Get and store type
        let ty = self.type_()?;
        Ok(Parameter { ident, ty })
    }</code></pre>
<h3 id="primitives-types-etc"><a class="header" href="#primitives-types-etc">Primitives, types, etc.</a></h3>
<p>We've reached a point where there are quite a lot of errors on the screen though. Let's cut down on how many errors we see by implementing the <code>type</code>, and <code>ident</code> methods now.</p>
<h4 id="types"><a class="header" href="#types">Types</a></h4>
<p>Types are simple, we can just match and return a token which are valid types. We can put the primitive types here for now:</p>
<pre><code class="language-rust ignore">    fn type_(&amp;mut self) -&gt; Result&lt;Type&gt; {
        match self.current_or_eof()?.kind {
            TokenKind::Int =&gt; {
                self.advance();
                Ok(Type::Primitive(PrimitiveType::Int))
            }
            TokenKind::Bool =&gt; {
                self.advance();
                Ok(Type::Primitive(PrimitiveType::Bool))
            }
            _ =&gt; Err(anyhow!(LangError::ExpectedAnyToken {
                expected: vec![TokenKind::Int, TokenKind::Bool,],
                found: self.current_or_eof()?.kind.clone(),
                span: self.current_or_eof()?.span.clone(),
            })),
        }
    }</code></pre>
<h4 id="ident"><a class="header" href="#ident"><code>ident</code></a></h4>
<p>Identifier is very very straight-forward. Thanks to our tokenization, we don't need any complex rules since the identifier tokens are already recognised by the lexer. This is simply a function to reduce boilerplate by giving a consistent error message:</p>
<pre><code class="language-rust ignore">    fn ident(&amp;mut self) -&gt; Result&lt;Ident&gt; {
        match self.current_or_eof()?.kind {
            TokenKind::Ident(ref ident) =&gt; {
                let ident = ident.clone();
                self.advance();
                Ok(Ident { ident })
            }
            _ =&gt; Err(anyhow!(LangError::ExpectedToken {
                expected: TokenKind::Ident("".to_string()),
                found: self.current_or_eof()?.kind.clone(),
                span: self.current_or_eof()?.span.clone(),
            })),
        }
    }</code></pre>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>Recall the <code>block</code> non-terminal production rule:</p>
<pre><code class="language-ebnf">block             ::= "{" statement* "}"
</code></pre>
<p>This is pretty simple, we just need to parse 0 or more statements. We can implement this as a loop that keeps parsing statements until we reach the end of the block.</p>
<pre><code class="language-rust ignore">    fn block(&amp;mut self) -&gt; Result&lt;Block&gt; {
        // "{"
        self.expect(TokenKind::LBrace)?;

        let mut statements = Vec::new();
        while self.current_or_eof()?.kind != TokenKind::RBrace {
            statements.push(self.statement()?);
        }

        // "}"
        self.expect(TokenKind::RBrace)?;

        Ok(Block { statements })
    }</code></pre>
<h3 id="statements--variable_decl-flow_statement-return_statement"><a class="header" href="#statements--variable_decl-flow_statement-return_statement">Statements (+ <code>variable_decl</code>, <code>flow_statement</code>, <code>return_statement</code>)</a></h3>
<p>Now we're entering the territory of parsing expressions, something a lot of people struggle with.</p>
<pre><code class="language-ebnf">statement         ::= expression
                    | variable_decl ";"
                    | return_statement ";"
                    | flow_statement ";"
</code></pre>
<p>For this non-terminal, the production rule will be either <code>expression</code>, <code>variable_decl</code>, or <code>flow_statement</code>. The easiest and clearest way to determine which to branch off to is simply the starting token:</p>
<ul>
<li><code>Let</code> implies <code>variable_decl</code></li>
<li><code>If</code> implies <code>flow_statement</code></li>
<li><code>Return</code> implies <code>return_statement</code></li>
<li>Anything else implies <code>expression</code></li>
</ul>
<p>We can implement this as a simple match statement:</p>
<pre><code class="language-rust ignore">    fn statement(&amp;mut self) -&gt; Result&lt;Statement&gt; {
        match self.current_or_eof()?.kind {
            TokenKind::Let =&gt; self.variable_decl(),
            TokenKind::If =&gt; self.flow_statement(),
            TokenKind::Return =&gt; self.return_statement(),
            _ =&gt; Err(anyhow!(LangError::ExpectedAnyToken {
                expected: vec![TokenKind::Let,],
                found: self.current_or_eof()?.kind.clone(),
                span: self.current_or_eof()?.span.clone(),
            })),
        }
    }</code></pre>
<p>Let's explore each in order:</p>
<h4 id="variable_decl"><a class="header" href="#variable_decl"><code>variable_decl</code></a></h4>
<p>The <code>variable_decl</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">variable_decl     ::= "let" IDENTIFIER ":" type "=" expression ";"
</code></pre>
<p>A relatively trivial process, we just need to follow the grammar:</p>
<pre><code class="language-rust ignore">    fn variable_decl(&amp;mut self) -&gt; Result&lt;Statement&gt; {
        // "let"
        self.expect(TokenKind::Let)?;

        // IDENTIFIER
        let ident = self.ident()?;

        // ":"
        self.expect(TokenKind::Colon)?;

        // type
        let ty = self.type_()?;

        // "="
        self.expect(TokenKind::Equals)?;

        // expression
        let expression = self.expression()?;

        let var_decl = Statement::VariableDecl(VariableDecl {
            ident,
            ty,
            expression,
        });

        // ";"
        self.expect(TokenKind::Semicolon)?;

        Ok(var_decl)
    }</code></pre>
<h4 id="flow_statement"><a class="header" href="#flow_statement"><code>flow_statement</code></a></h4>
<p>The <code>flow_statement</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">flow_statement    ::= "if" expression block {"else" block}
</code></pre>
<p>This is a simple process:</p>
<ol>
<li>Expect <code>if</code></li>
<li>Parse and store <code>expression</code></li>
<li>Parse and store <code>block</code></li>
<li>Branch depending on token, and store:
<ul>
<li><code>else</code>: parse and store <code>block</code> -&gt; <code>Some(block)</code></li>
<li>Anything else: return <code>None</code></li>
</ul>
</li>
</ol>
<pre><code class="language-rust ignore">    fn flow_statement(&amp;mut self) -&gt; Result&lt;Statement&gt; {
        // "if"
        self.expect(TokenKind::If)?;

        // condition
        let condition = self.expression()?;

        // block
        let if_block = self.block()?;

        // may be else, may be not
        let else_block = if self.current_or_eof()?.kind == TokenKind::Else {
            self.advance();
            Some(self.block()?)
        } else {
            None
        };

        let stmt = Statement::Flow(FlowStatement {
            condition,
            if_block,
            else_block,
        });

        Ok(stmt)
    }</code></pre>
<h4 id="return_statement"><a class="header" href="#return_statement"><code>return_statement</code></a></h4>
<p>The <code>return_statement</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">return_statement  ::= "return" {expression} ";"
</code></pre>
<p>We can convert this to code quite easily:</p>
<pre><code class="language-rust ignore">    fn return_statement(&amp;mut self) -&gt; Result&lt;Statement&gt; {
        // "return"
        self.expect(TokenKind::Return)?;

        // expression or not
        let expression = if self.current_or_eof()?.kind != TokenKind::Semicolon {
            Some(Box::new(self.expression()?))
        } else {
            None
        };

        // ";"
        self.expect(TokenKind::Semicolon)?;

        let stmt = Statement::Return(expression);

        Ok(stmt)
    }</code></pre>
<h3 id="expressions"><a class="header" href="#expressions">Expressions</a></h3>
<p>Prior to this, we followed straight-forward rules. Here, we'll have to implement operator precedence. This is a bit more complex, but we'll start with the simple stuff.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Associativity will not be covered, since we don't have any right-associative operators (like exponentiation).</p>
</blockquote>
<h4 id="expression"><a class="header" href="#expression"><code>expression</code></a></h4>
<p>Here's the grammar for <code>expression</code>:</p>
<pre><code class="language-ebnf">expression        ::= primary_expression
                    | unary_expression
                    | binary_expression
</code></pre>
<p>This states that it can be one of stated three expression types. First, we'll make a simplistic approach where we calculate the left-hand side (lhs), and then the right-hand side (rhs). We'll then combine them into a <code>BinaryExpression</code> if we find an operator.</p>
<pre><code class="language-rust ignore">    fn expression(&amp;mut self) -&gt; Result&lt;Expression&gt; {
        let lhs = self.primary_expression()?;

        // Check if there's an operator
        if let Some(op) = self.current()?.binary_operator() {
            self.advance();
            let rhs = self.expression()?;
            Ok(Expression::Binary(BinaryExpression {
                lhs: Box::new(lhs),
                op: op.clone(),
                rhs: Box::new(rhs),
            }))
        } else {
            Ok(lhs)
        }
    }</code></pre>
<p>The problem with this approach is that it doesn't handle operator precedence (i.e. the following binary expression will take precedence over the previous one).</p>
<p>Instead of determining the left and right-hand side, we'll maintain a mutable <code>expr</code> variable and keep updating it as we parse the expression.</p>
<p>To do this, we would terminate the loop of updating <code>expr</code> when the operator being parsed is of a lower precedence than the previous expression. We need a way to determine the operator of a given expression first, if any. Let's implement a helper method in <code>src/ast/expr.rs</code>:</p>
<pre><code class="language-rust ignore">impl Expression {
    /// Get the binary operator of the expression, if any
    pub fn binary_operator(&amp;self) -&gt; Option&lt;&amp;BinaryOperator&gt; {
        match self {
            Expression::Binary(binary_expr) =&gt; Some(&amp;binary_expr.op),
            _ =&gt; None,
        }
    }
}</code></pre>
<p>With this, we can start implementing the new algorithm. Here's the process:</p>
<ol>
<li>Parse &amp; store <code>expr</code></li>
<li>While there is an operator, continue this loop:
<ol>
<li>If the operator has a lower precedence than the previous operator, break the loop</li>
<li>Parse the <code>rhs = primary()</code> and store it</li>
<li>Update <code>expr</code> to a new <code>BinaryExpression</code> with <code>lhs</code>, <code>rhs</code>, and the current <code>op</code></li>
<li>Repeat the loop with the top condition</li>
</ol>
</li>
</ol>
<p>The new algorithm will allow us to retain information about the left-hand side expression and whether or not it should take precedence over the new right-hand side.</p>
<pre><code class="language-rust ignore">    fn expression(&amp;mut self) -&gt; Result&lt;Expression&gt; {
        let mut expr = self.primary()?;

        while let Some(op) = self.current_or_eof()?.kind.as_binary_operator() {
            let op_precedence = op.precedence();

            // Check if the operator precedence is higher than the previous operator
            if let Some(prev_op) = expr.binary_operator() {
                if op_precedence &lt;= prev_op.precedence() {
                    break; // Break the loop if the current operator has lower precedence
                }
            }

            // Consume the operator token
            self.advance();

            // Parse the right-hand side expression
            let rhs = self.primary()?;

            // Parse binary expression
            expr = Expression::Binary(BinaryExpression {
                lhs: Box::new(expr),
                op: op,
                rhs: Box::new(rhs),
            });
        }

        Ok(expr)
    }</code></pre>
<h4 id="primary_expression"><a class="header" href="#primary_expression"><code>primary_expression</code></a></h4>
<p>The <code>primary_expression</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">primary_expression ::= literal
                    | IDENTIFIER
                    | "(" expression ")"
                    | function_call
</code></pre>
<p>This is a straightforward <code>match</code> statement, and so we'll implement it as such:</p>
<pre><code class="language-rust ignore">    fn primary(&amp;mut self) -&gt; Result&lt;Expression&gt; {
        match self.current_or_eof()?.kind {
            TokenKind::IntLiteral(_) | TokenKind::BoolLiteral(_) =&gt; {
                self.literal().map(Expression::Primary)
            }
            TokenKind::Ident(_) =&gt; {
                let ident = self.ident()?;
                Ok(Expression::Primary(PrimaryExpression::Ident(ident)))
            }
            TokenKind::LParen =&gt; {
                self.advance();
                let expr = self.expression()?;
                self.expect(TokenKind::RParen)?;
                Ok(Expression::Primary(PrimaryExpression::Parenthesized(
                    Box::new(expr),
                )))
            }
            _ =&gt; Err(anyhow!(LangError::ExpectedAnyToken {
                expected: vec![
                    TokenKind::IntLiteral(0),
                    TokenKind::BoolLiteral(false),
                    TokenKind::Ident("".to_string()),
                    TokenKind::LParen,
                ],
                found: self.current_or_eof()?.kind.clone(),
                span: self.current_or_eof()?.span.clone(),
            })),
        }
    }</code></pre>
<h4 id="unary-expressions"><a class="header" href="#unary-expressions">Unary expressions</a></h4>
<p>For simplicity sake, we'll implement the unary operators within the <code>expression</code> function.</p>
<p>To do this, we'll add a loop to handle unary operators. We'll parse the right-hand side expression, and then handle the unary operator. We'll then update <code>expr</code> to a new <code>UnaryExpression</code> with the current <code>op</code> and <code>rhs</code>.</p>
<p>Let's adjust the loop:</p>
<pre><code class="language-rust ignore">        while let Some(op) = self.current_or_eof()?.kind.as_binary_operator() {
            // ...

            // Parse the right-hand side expression
            let rhs = self.primary()?;

            // Handle unary operators
            while let Some(unary_op) = self.current_or_eof()?.kind.as_unary_operator() {
                // Consume the operator token
                self.advance();

                // Parse the right-hand side expression
                let rhs = self.primary()?;

                let unary_expression = match unary_op {
                    UnaryOperator::Negate =&gt; UnaryExpression::Negation(Box::new(rhs)),
                    UnaryOperator::Not =&gt; UnaryExpression::Not(Box::new(rhs)),
                };

                expr = Expression::Unary(unary_expression);
            }

            // Parse binary expression
            expr = Expression::Binary(BinaryExpression {
                lhs: Box::new(expr),
                op: op,
                rhs: Box::new(rhs),
            });
        }</code></pre>
<h4 id="literal"><a class="header" href="#literal"><code>literal</code></a></h4>
<p>The <code>literal</code> non-terminal grammar is as follows:</p>
<pre><code class="language-ebnf">literal           ::= INT | FLOAT | BOOLEAN
</code></pre>
<p>This is a simple process, we just need to match and return a token which are valid literals:</p>
<pre><code class="language-rust ignore">    fn literal(&amp;mut self) -&gt; Result&lt;PrimaryExpression&gt; {
        match self.current_or_eof()?.kind {
            TokenKind::IntLiteral(value) =&gt; {
                self.advance();
                Ok(PrimaryExpression::Literal(Literal::Int(value)))
            }
            TokenKind::BoolLiteral(value) =&gt; {
                self.advance();
                Ok(PrimaryExpression::Literal(Literal::Bool(value)))
            }
            _ =&gt; Err(anyhow!(LangError::ExpectedAnyToken {
                expected: vec![TokenKind::IntLiteral(0), TokenKind::BoolLiteral(false),],
                found: self.current_or_eof()?.kind.clone(),
                span: self.current_or_eof()?.span.clone(),
            })),
        }
    }</code></pre>
<h4 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h4>
<p>Again, we will directly implement parsing function calls inside <code>primary</code> (primary_expressions). This is because function calls are a part of the primary expression, and so it makes sense to implement it here.</p>
<p>In the <code>TokenKind::Ident(_)</code> match, we'll check if the next token is an <code>LParen</code>. If it is, we'll parse the arguments and return a <code>FunctionCall</code> expression.</p>
<pre><code class="language-rust ignore">            TokenKind::Ident(_) =&gt; {
                let ident = self.ident()?;

                // Function call
                if self.current_or_eof()?.kind == TokenKind::LParen {
                    self.advance();
                    let args = self.expression_list()?;
                    self.expect(TokenKind::RParen)?;
                    Ok(Expression::Primary(PrimaryExpression::FunctionCall(
                        FunctionCall { ident, args },
                    )))
                } else {
                    Ok(Expression::Primary(PrimaryExpression::Ident(ident)))
                }
            }</code></pre>
<p>Let's implement the <code>expression_list</code> method now. This is a simple process, we just need to parse 0 or more expressions. We can implement this as a loop that keeps parsing expressions until we reach the end of the list.</p>
<pre><code class="language-rust ignore">    fn expression_list(&amp;mut self) -&gt; Result&lt;Vec&lt;Expression&gt;&gt; {
        let mut args = Vec::new();
        while self.current_or_eof()?.kind != TokenKind::RParen {
            args.push(self.expression()?);
            if self.current_or_eof()?.kind == TokenKind::Comma {
                self.advance();
            }
        }
        Ok(args)
    }</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>That's quite a lot of code. In fact, currently my <code>parser.rs</code> file is at 482 lines! It's a good idea to test the parser to ensure it's working as expected.</p>
<p>This section would a lot cleaner if you completed the section on <a href="./implementing_an_ast.html#optional-helpers">AST Optional Helper Methods</a>. You can still debug-print them if you haven't, but it's a lot more convenient to use the helper methods.</p>
<p>Let's run the test on this file:</p>
<pre><code class="language-rust ignore">fn main() -&gt; int {
    let a: int = 5 + 2;
    let b: int = 6;
    let c: int = a + b;
    return c;
}</code></pre>
<p>This is a test in the <code>main::add_compile</code>, so we can try <code>cargo test add_compile -- -nocapture</code> to test &amp; view the output.</p>
<p>We get the following output:</p>
<pre><code>Program
    FuncDecl main() -&gt; int {
        Block
            VariableDecl a:int =
                BinaryExpression
                op=Add
                    Int 5
                    Int 2
            VariableDecl b:int =
                Int 6
            VariableDecl c:int =
                BinaryExpression
                op=Add
                    Ident a
                    Ident b
            Return
                Ident c
    }
</code></pre>
<p>It seems to be working pretty well! One of the typical errors is forgetting a semicolon, so let's see if it catches that too.</p>
<pre><code class="language-rust ignore">fn main() -&gt; int {
    let a: int = 5 + fn 2;
    let b: int = 6;
    let c: int = a + b;
    return c;
}</code></pre>
<p>With the same call, we get:</p>
<pre><code class="language-plaintext">Error:
   ╭─[tests/add.pyl:2:22]
   │
 2 │     let a: int = 5 + fn 2;
   │                      ─┬
   │                       ╰── Expected any of the tokens: `IntegerLiteral`, `BooleanLiteral`, `Ident`, `(`, found: `fn`
───╯
Error: Failed to parse file
</code></pre>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<ul>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html">RefCell documentation</a></li>
<li><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html">RefCell in book</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="implementing_an_ast.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="semantic_analysis.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="implementing_an_ast.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="semantic_analysis.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
