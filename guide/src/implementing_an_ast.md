# Implementing an AST
Now that we have:
- A Lexer
- A way to represent tokens
- A way to represent errors

We now need to implement an Abstract Syntax Tree from the grammar we developed, and derive a parser from it. We'll add some more methods later on during parsing, since the best explanatory example is a working example.

## Designing the AST
Recall the [grammar we designed](./context_free_grammars.md#lets-design-a-grammar) for our language. We will use this grammar to design our AST.

<details>
<summary><strong>View the grammar</strong></summary>

```ebnf
program           ::= item*

item              ::= function_decl
                    # | struct_decl
                    # | enum_decl
                    # | impl_block

function_decl     ::= "fn" IDENTIFIER "(" {parameter_list} ")" "->" type block

parameter_list    ::= parameter ("," parameter)*

parameter         ::= IDENTIFIER ":" type

type              ::= primitive_type
                    # | user_defined_type
                    # | tuple_type
                    # | reference_type
                    # | array_type
                    # | function_type

primitive_type    ::= "int" | "float" | "bool"

block             ::= "{" statement* "}"

statement         ::= expression
                    | variable_decl ";"
                    | flow_statement ";"


expression        ::= primary_expression
                    | unary_expression
                    | binary_expression

primary_expression ::= literal
                    | IDENTIFIER
                    | "(" expression ")"
                    | function_call

literal           ::= INT | FLOAT | BOOLEAN

unary_expression  ::= "-" expression | "!" expression #| "&" expression | "*" expression

binary_expression ::= expression OPERATOR expression

function_call     ::= IDENTIFIER "(" arguments ")"
arguments         ::= expression ("," expression)* | Îµ

variable_decl     ::= "let" IDENTIFIER ":" type "=" expression

flow_statement    ::= "if" expression block {"else" block}
                    | "return" expression?
```

</details>

We can simply go one-by-one and design the AST for each non-terminal in the grammar.

### File Structure
We currently have a `src` directory with the following structure:
```
compiler/
|-- Cargo.toml
|-- grammar.bnf
+-- src
  +-- ast           // An empty AST folder
  |-- errors.rs
  |-- lexer.rs
  |-- main.rs
  |-- parser.rs
  |-- token.rs
+-- tests
```

It would be significantly beneficial to have a separate file for each non-terminal in the grammar. We can also group them into little categories, which we'll do here:

In `src/ast`, we'll have:
1. `core.rs` for the core items in the language (`Program`, etc.)
2. `expr.rs` for the expressions
3. `flow.rs` for the flow statements
4. `functions.rs` for the different function non-terminals
5. `nary_expr.rs` representing any -ary expressions (unary, binary, etc.)
6. `ops.rs` for the operators
7. `prim_expr.rs` for the primary expressions
8. `types.rs` for all datatypes, including primitive

We'll also have a `mod.rs` file in the `ast` folder to re-export everything, which will look like this simply:
```rust,ignore
//! Declares the AST for the language.
//! 
//! Abstract Syntax Trees (ASTs) represent the structure of the language,
//! generated by the parser. Raw parser ASTs should be optimized further.
//! 
//! We can use this to generate the IR (Intermediate Representation) for the
//! language, which is then used to generate the final machine code.

// Load all the modules
mod core;
mod ops;
mod types;
mod prim_expr;
mod nary_expr;
mod expr;
mod functions;
mod flow;
mod utils;

// Re-export everything
pub use self::core::*;
pub use self::ops::*;
pub use self::types::*;
pub use self::prim_expr::*;
pub use self::nary_expr::*;
pub use self::expr::*;
pub use self::functions::*;
pub use self::flow::*;
pub use self::utils::*;
```

This is a little bit tedious, but let's get started.

It's important to note that since parts of the AST may refer to sister-modules, we'll add `use crate::ast::*;` to the top of each file.

### Core Items
This will consist of the `Program` and `Item` non-terminals. Additionally, we'll also wrap the entire program into an `AST` struct, which will also contain the `file_id`:

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub struct AST {
    pub program: Program,
    pub file_id: usize,
}

#[derive(Debug)]
pub struct Program {
    pub items: Vec<Item>,
}

#[derive(Debug)]
pub enum Item {
    FunctionDecl(FunctionDecl),
}
```

### Expressions
Referring to our grammar, expressions are either:
- Primary expressions
- Unary expressions
- Binary expressions

Blocks are also expressions, so we'll consider them too.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum Expression {
    Primary(PrimaryExpression),
    Unary(UnaryExpression),
    Binary(BinaryExpression),
}

#[derive(Debug)]
pub struct Block {
    pub statements: Vec<Statement>,
}
```

### Flow Statements
Flow statements consist of `if`, `return`, etc. but we will include regular statements within this too.

Referring to our grammar, statements are either:
- Expressions
- Variable declarations
- Flow statements
- Return statements

We will not include the nodes for expressions here.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum Statement {
    Expression(Box<Expression>),
    VariableDecl(VariableDecl),
    Flow(FlowStatement),
    Return(Box<Expression>),
}

#[derive(Debug)]
pub struct VariableDecl {
    pub ident: Ident,
    pub ty: Type,
    pub expression: Expression,
}

#[derive(Debug)]
pub struct FlowStatement {
    pub condition: Expression,
    pub if_block: Block,
    pub else_block: Option<Block>,
}
```

### Functions
Next, we simply need to determine how a `FunctionDecl` node will look like. Referring to our grammar, we can abstract away parentheses, commas, etc. and determine that the information a function contains is:
1. An identifier
2. A list of parameters
3. A return type
4. A block (the function body)

We should create nodes for parameters too, as they are a part of the function declaration.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub struct FunctionDecl {
    pub ident: Ident,
    pub parameters: Vec<Parameter>,
    pub ty: Type,
    pub block: Block,
}

#[derive(Debug)]
pub struct Parameter {
    pub ident: Ident,
    pub ty: Type,
}
```

### N-ary Expressions
To support unary and binary operations, we'll add these nodes here.

Unary expressions will simply either be a `Negation` unary operation, or a `Not` unary operation.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum UnaryExpression {
    Negation(Box<Expression>),
    Not(Box<Expression>),
}

#[derive(Debug)]
pub struct BinaryExpression {
    pub lhs: Box<Expression>,
    pub op: BinaryOperator,
    pub rhs: Box<Expression>,
}
```

### Operators
This part will be slightly longer, as we need to determine the **precedence** of each operator.

First, let's define the `enum`:

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum BinaryOperator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulus,
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessThanOrEqual,
    GreaterThanOrEqual,
    And,
    Or,
}
```

**Operator Precedence** is a critical part of parsing expressions; they define the order in which operators are evaluated. For example, `*` has a higher precedence than `+`, so `2 + 3 * 4` should be parsed as `2 + (3 * 4)`. You may know this as BIDMAS, BODMAS, or PEMDAS.

First, we know that the highest precedence operator (here, atleast) are the multiplication, division, and modulus operators. Below them are addition and subtraction.

Then there's the relational comparison operators; we would like them to be lower than the arithmetic operations so we can perform evaluations like `3 + 4 < 5 + 6` as `(3 + 4) < (5 + 6)`.

Equality comparison operators (`==`, `!=`) should have lower precedence than relational operators.

Finally, let's look at the logical operators `&&` and `||`. We would like them to have the lowest precedence, **but** there is a difference. Consider `true || false && true`. We would like this to be parsed as `true || (false && true)`. Thus, `&&` should have a higher precedence than `||`.

Let's start from the bottom up and list the operators in terms of order:

1. `||`: `Or`
2. `&&`: `And`
3. `==`, `!=`: Equality Comparison Operators
4. `<`, `>`, `<=`, `>=`: Relational Comparison Operators
5. `+`, `-`: Addition and Subtraction
6. `*`, `/`, `%`: Multiplication, Division, and Modulus

See the numbers on the list? That would be the precedence value of the operators. We can add this to the `BinaryOperator` enum:

```rust,ignore
impl BinaryOperator {
    /// Get the precedence of the operator
    pub fn precedence(&self) -> u8 {
        match self {
            BinaryOperator::Or => 1,
            BinaryOperator::And => 2,
            BinaryOperator::Equal | BinaryOperator::NotEqual => 3,
            BinaryOperator::LessThan
            | BinaryOperator::GreaterThan
            | BinaryOperator::LessThanOrEqual
            | BinaryOperator::GreaterThanOrEqual => 4,
            BinaryOperator::Add | BinaryOperator::Subtract => 5,
            BinaryOperator::Multiply | BinaryOperator::Divide | BinaryOperator::Modulus => 6,
        }
    }
}
```

### Primary Expressions
Primary expressions, as referred to in our grammar, are:
- Literals
- Identifiers
- Parenthesized expressions
- Function calls

Keep in mind we do want to minimize the number of AST Nodes we create, so we will skip the creation of paranthesized expressions and function calls. However, we would like to explicitly represent literals and identifiers.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum PrimaryExpression {
    Literal(Literal),
    Ident(Ident),
    Parenthesized(Box<Expression>),
    FunctionCall(String, Vec<Expression>),
}

#[derive(Debug)]
pub struct Ident {
    pub ident: String,
}

#[derive(Debug)]
pub enum Literal {
    Int(i32),
    Float(f32),
    Bool(bool),
}
```

### Types
Finally, we need to represent the different types in our language. We'll start with the primitive types.

```rust,ignore
use crate::ast::*;

#[derive(Debug)]
pub enum Type {
    Primitive(PrimitiveType),
}

#[derive(Debug)]
pub enum PrimitiveType {
    Int,
    Float,
    Bool,
}
```

## Optional helpers
We can add some helpful methods to display the tree. One option is to implement [`Display` trait](https://doc.rust-lang.org/std/fmt/trait.Display.html), although I prefer using a custom method for this to keep track of depth or indentation.

Let's create `ast/utils.rs`:

```rust,ignore
pub trait PrettyPrint {
    fn pretty_print(&self, indent: usize) -> String;
}
```

This is a trait we'll implement for each node in the AST, which takes in an `indent` parameter to determine how much to indent the output.

Unfortunately I will not cover each node, but we'll cover the `FunctionDecl` node as an example:

```rust,ignore
impl PrettyPrint for FunctionDecl {
    // format: FuncDecl ident(parameters) -> ty { block }
    fn pretty_print(&self, indent: usize) -> String {
        let mut s = format!(
            "{:indent$}FuncDecl {}({}) -> {} {{\n",
            "",
            self.ident.ident,
            self.parameters
                .iter()
                .map(|p| p.pretty_print(indent))
                .collect::<Vec<String>>()
                .join(", "),
            self.ty.pretty_print(indent),
            indent = indent * 4
        );
        s.push_str(&self.block.pretty_print(indent + 1));
        s.push_str(&format!("{:indent$}}}\n", "", indent = indent * 4));
        s
    }
}
```

This will allow us to call `pretty_print` on any node in the AST, and it will return a string representation of the node.

# Resources
- [Operator Precedence](https://en.wikipedia.org/wiki/Operator-precedence_parser)
- [Box<T>](https://doc.rust-lang.org/std/boxed/struct.Box.html)
- [`Display` trait](https://doc.rust-lang.org/std/fmt/trait.Display.html)