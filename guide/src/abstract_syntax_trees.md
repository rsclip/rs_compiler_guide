# Abstract Syntax Trees
## Introduction to ASTs
In order to understand the structure of a program, we need to interpet and parse it in a way that is easy to understand and manipulate.

An abstract syntax tree (AST) is a tree representation of the abstract syntactic structure of source code written in a programming language. Each node of the tree denotes a construct occurring in the source code. The syntax is "abstract" in the sense that it does not represent every detail appearing in the real syntax of the programming language.

### Components of ASTs
ASTs are structured the same way general Tree Data Structures are, except that:
1. Each node in the tree represents a construct in the source code.
2. The children of a node are the subconstructs of the construct represented by the node.

Let's take a look at an example of an AST for the following C code:
```c
int main() {
    return 0;
}
```

The AST for the above code would look like this:
```
Program
    |
    └── FunctionDeclaration
        |
        ├── TypeSpecifier
        |   |
        |   └── int
        |
        ├── Identifier
        |   |
        |   └── main
        |
        └── CompoundStatement
            |
            └── ReturnStatement
                |
                └── Constant
                    |
                    └── 0
```

Each node can represent different constructs in the source code, such as:
- Function, variable, and type declarations
- Control structures (if, while, for, etc.)
- Expressions (arithmetic, logical, etc.)
- Statements (assignments, function calls, etc.)
- Literals (integers, strings, etc.)

### Uses of ASTs
ASTs are used in many areas of computer science, such as:
- **Compilers**: Used to represent the structure of the source code
- **Code analysis and transformation**: Used to analyze and transform source code
- **Language processing**: Used in natural language processing to represent the structure of sentences and phrases

Of course, we will focus on the use of ASTs in compilers.

### Constructing an AST
The process of constructing an AST from source code is called **parsing**. This process involves analyzing the tokens generated by the lexer and constructing a tree that represents the structure of the source code.

Parsing is a complex process, and is dependent on the grammar it follows -- as well as the parsing technique you use. We will cover these topics in more detail in the next sections. Regardless, the common goal is to construct a tree that represents the structure of the source code, given a stream of tokens.

## Traversal
Once we have constructed an AST, there are two main ways to traverse it:

1. **Depth-First Traversal**: In this traversal, we start at the root node and explore as far as possible along each branch before backtracking. This is the most common way to traverse an AST, and is used in many algorithms that operate on trees.

2. **Breadth-First Traversal**: In this traversal, we visit all the nodes on a level before moving to the next level. This is less common, but can be useful in certain scenarios.

## Alternative representations
There are other ways to represent the syntactic structure of a program. One such example are **Concrete Syntax Trees (CSTs)**, which represent the concrete syntax of the program. The main difference between CSTs and ASTs is that CSTs represent every detail of the syntax, including whitespace and comments.

Rust's `syn` crate is a good example of a library that uses CSTs to represent the syntax of Rust code. It provides a way to parse Rust code into a CST, and then manipulate it using Rust's syntax.

Some useful features of CSTs include:
- **Preservation of whitespace and comments**: This can be useful when you want to preserve the original formatting of the code. Rust uses this to generate documentation from the comments in the code.
- **More detailed error messages**: Since CSTs represent the concrete syntax of the program, they can provide more detailed error messages when parsing fails.

However, ASTs are more abstract and thus are more commonly used in compilers and language processing. We will be using this representation in our compiler.

# Resources
- [Abstract Syntax Trees - Wikipedia](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
- [ASTs vs CSTs](https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees)
- [Rust Syn crate](https://docs.rs/syn/1.0.72/syn/)
- [Tree Data Structures](https://en.wikipedia.org/wiki/Tree_(data_structure))
- [Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal)
- [DFS, BFS](https://www.cs.cornell.edu/courses/cs2110/2017sp/online/dfs/dfs01.html)